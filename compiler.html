<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Prompt Compiler — Continuity Lock (v3)</title>
  <style>
    :root{--r:14px}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0d12;color:#eef2ff;line-height:1.35}
    header{
      padding:22px 18px;border-bottom:1px solid rgba(255,255,255,.08);
      background:
        radial-gradient(1200px 600px at 20% 0%, rgba(99,102,241,0.22), transparent 60%),
        radial-gradient(800px 400px at 80% 0%, rgba(16,185,129,0.18), transparent 55%);
    }
    header h1{margin:0 0 6px;font-size:20px}
    header p{margin:0;opacity:.85;max-width:1100px}
    a{color:#a5b4fc;text-decoration:none} a:hover{text-decoration:underline}
    main{max-width:1200px;margin:0 auto;padding:18px;display:grid;gap:16px}
    .grid{display:grid;gap:16px;grid-template-columns:1fr}
    @media(min-width:980px){.grid{grid-template-columns:1fr 1fr}}
    .card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.10);border-radius:var(--r);padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .card h2{margin:0 0 10px;font-size:15px;opacity:.95}
    label{font-size:12px;opacity:.85;display:block;margin-bottom:6px}
    textarea{
      width:100%;min-height:420px;resize:vertical;white-space:pre-wrap;
      padding:10px 11px;border-radius:12px;border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.35);color:#eef2ff;outline:none;box-sizing:border-box
    }
    .btnbar{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px}
    button{border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);color:#eef2ff;padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:800}
    button.primary{background:rgba(99,102,241,.22);border-color:rgba(99,102,241,.45)}
    button.good{background:rgba(16,185,129,.18);border-color:rgba(16,185,129,.40)}
    button:hover{filter:brightness(1.08)}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:7px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.05);font-size:12px}
    .pill b{font-weight:900}
    .muted{opacity:.78;font-size:12px}
    .cards{display:grid;gap:12px}
    .scene{background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.10);border-radius:12px;padding:12px}
    .top{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:8px}
    .top b{font-size:13px}
    pre{margin:0;white-space:pre-wrap;font-size:13px}
    .ok{border:1px solid rgba(16,185,129,.35);background:rgba(16,185,129,.10);padding:10px;border-radius:12px;margin-bottom:10px}
    .err{border:1px solid rgba(245,158,11,.4);background:rgba(245,158,11,.12);padding:10px;border-radius:12px;margin-bottom:10px}
    .k{color:#a5b4fc;font-weight:800}
  </style>
</head>
<body>
<header>
  <h1>Prompt Compiler — Continuity Lock (v3)</h1>
  <p>
    Paste the Story Frame from the generator (<span class="k">STORY SETTINGS + PROP DNA + SCENES</span>) or legacy format.
    This compiler injects Master Style + Character DNA into every scene prompt.
    <br><br><a href="./index.html">← Back to Story Generator</a>
  </p>
</header>

<main class="grid">
  <section class="card">
    <h2>1) Input — Story Frame</h2>
    <label>Paste here</label>
    <textarea id="input"></textarea>
    <div class="btnbar">
      <button class="primary" id="compile">Compile</button>
      <button class="good" id="copyAll">Copy All</button>
      <span class="pill" id="status"><b>Status:</b> Ready</span>
    </div>
    <div class="muted" style="margin-top:10px;">
      Tip: DNA and PROP DNA are repeated in every prompt to prevent “AI amnesia”.
    </div>
  </section>

  <section class="card">
    <h2>2) Output — Scene Prompts</h2>
    <div id="msg"></div>
    <div class="cards" id="cards"></div>
  </section>
</main>

<script>
const MASTER_STYLE =
`10-second cinematic scene. Soft, natural realism with gentle warmth. No dialogue, no text, no subtitles, no logos. Simple, readable action with lively, purposeful movement. Camera: Static or very slow tracking shot. Photorealistic animal anatomy. Natural fur texture and sunlight. NO 3D animation style. NO "Disney" eyes. Physical interactions grounded in physics (objects have weight). NO human limbs.`;

const DNA = {
  WILLY: `WILLY: (Baby Golden Retriever puppy. Light-golden velvet-soft fluffy fur, short legs, small floppy ears. Simple RED COLLAR. SIGNATURE: A tiny pink "blep" tip of tongue always peeking out of his mouth).`,
  PANBY: `PANBY: (Baby Giant Panda, chubby and round. Jet-black fur on limbs/eyes, snow-white fur on head/belly. Small bright YELLOW fabric bowtie).`,
  QUOK: `QUOK: (Baby Quokka. Short brown-grey fur, small rounded ears, permanent gentle "smiling" expression).`
};

function el(id){return document.getElementById(id);}
function setStatus(t){el("status").innerHTML="<b>Status:</b> "+t;}
function linesOf(t){return (t||"").replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");}

function section(lines, header){
  const idx = lines.findIndex(l=>l.trim().toUpperCase()===header);
  if (idx<0) return null;
  let end = lines.length;
  for (let i=idx+1;i<lines.length;i++){
    const u = lines[i].trim().toUpperCase();
    if (u==="STORY TITLE" || u==="STORY SETTINGS" || u==="PROP DNA (MUST BE REPEATED VERBATIM IN PROMPTS)" || u.startsWith("SCENES") || u==="SOP CHECK" || u==="STORY CORE" || u==="STORY TRAM"){
      end = i; break;
    }
  }
  return lines.slice(idx+1,end).map(x=>x.trim()).filter(Boolean);
}

function parseGeneratorFormat(lines){
  const titleLines = section(lines,"STORY TITLE");
  const settingsLines = section(lines,"STORY SETTINGS");
  const propLines = section(lines,"PROP DNA (MUST BE REPEATED VERBATIM IN PROMPTS)");
  const scenesIdx = lines.findIndex(l=>l.trim().toUpperCase().startsWith("SCENES"));
  if (!titleLines || scenesIdx<0) return null;

  const title = titleLines.join(" ").trim();
  const settings = (settingsLines||[]).join("\n").trim();
  const propDNA = (propLines||[]).join("\n").trim();

  const beats = [];
  for (let i=scenesIdx+1;i<lines.length;i++){
    const raw = lines[i].trim();
    if (!raw) continue;
    if (raw.toUpperCase()==="SOP CHECK") break;
    const m = raw.match(/^Scene\s*(\d+)\s*:\s*(.+)$/i);
    if (m) beats.push({n:parseInt(m[1],10), text:m[2].trim()});
  }
  if (!beats.length) return null;

  return {title, settings, propDNA, beats};
}

function parseLegacy(lines){
  const core = section(lines,"STORY CORE");
  const tram = section(lines,"STORY TRAM");
  if (!core || !tram) return null;
  const beats = tram.map((l,i)=>{
    const m = l.match(/^(\d+)\)\s*(.*)$/) || l.match(/^Scene\s*(\d+)\s*:\s*(.*)$/i);
    if (m) return {n:parseInt(m[1],10), text:(m[2]||"").trim()};
    return {n:i+1, text:l};
  });
  return {title:"", settings:core.join("\n"), propDNA:"", beats};
}

function detectCharacters(text){
  const s = (text||"").toLowerCase();
  const found = new Set();
  if (s.includes("willy")) found.add("WILLY");
  if (s.includes("panby")) found.add("PANBY");
  if (s.includes("quok")) found.add("QUOK");
  return Array.from(found);
}

function buildPrompt(sceneN, beatText, fullContext){
  const involved = detectCharacters(fullContext + "\n" + beatText);
  const dnaBlock = involved.length ? involved.map(k=>DNA[k]).join("\n") : DNA.WILLY; // default to Willy as channel core

  return [
    MASTER_STYLE,
    "",
    `SCENE ${sceneN} — FINAL PROMPT`,
    "",
    "DESCRIPTION (Blind-Viewer Protocol):",
    beatText,
    "",
    "CHARACTER STATES (Verbatim Anchor):",
    dnaBlock,
    "",
    "GAZE TARGET (Interaction Rule):",
    "- Characters look at each other or the key object/situation. NEVER look at the camera.",
    "",
    "PROPS & PHYSICS:",
    "- All objects maintain exact color/scale/markings from previous scenes. Realistic weight, gravity, friction.",
    "",
    "PROP DNA (Persistence Check):",
    fullContext.propDNA ? fullContext.propDNA : "(none provided)",
    "",
    "BIOLOGICAL BODY LANGUAGE:",
    "- Emotions shown through ears/tail/whiskers/posture/breathing. No abstract emotion words.",
    "",
    "REMEMBER (Continuity Lock):",
    "- Repeat the exact same character DNA and PROP DNA every time they appear.",
    "- One clear action per scene. Still/slow for detailed tool interaction.",
    "- No dialogue, no text, no subtitles, no logos."
  ].join("\n");
}

function compile(){
  const raw = el("input").value || "";
  const lines = linesOf(raw);

  let parsed = parseGeneratorFormat(lines);
  if (!parsed) parsed = parseLegacy(lines);

  if (!parsed){
    el("msg").innerHTML = `<div class="err"><b>ERROR:</b> Could not parse. Paste generator output with <span class="k">STORY SETTINGS + PROP DNA + SCENES</span>.</div>`;
    el("cards").innerHTML = "";
    setStatus("Error");
    return;
  }

  const ctx = { settings: parsed.settings, propDNA: parsed.propDNA };
  const fullContextText = (parsed.title?("TITLE: "+parsed.title+"\n"):"") + (parsed.settings?("SETTINGS:\n"+parsed.settings+"\n"):"") + (parsed.propDNA?("PROP DNA:\n"+parsed.propDNA+"\n"):"");

  el("msg").innerHTML = `<div class="ok"><b>OK:</b> Parsed ${parsed.beats.length} scenes${parsed.title?(" — <span class="k">"+parsed.title+"</span>"):""}.</div>`;
  const cards = el("cards");
  cards.innerHTML = "";

  parsed.beats.forEach(b=>{
    const prompt = buildPrompt(b.n, b.text, {propDNA: parsed.propDNA});
    const wrap = document.createElement("div");
    wrap.className = "scene";

    const top = document.createElement("div");
    top.className = "top";

    const title = document.createElement("b");
    title.textContent = `Scene ${b.n}`;

    const copyBtn = document.createElement("button");
    copyBtn.className = "good";
    copyBtn.textContent = "Copy";
    copyBtn.style.padding = "8px 10px";
    copyBtn.addEventListener("click", async ()=>{
      try{ await navigator.clipboard.writeText(prompt); setStatus(`Copied Scene ${b.n}`); }
      catch{ setStatus("Copy failed"); }
    });

    top.appendChild(title);
    top.appendChild(copyBtn);

    const pre = document.createElement("pre");
    pre.textContent = prompt;

    wrap.appendChild(top);
    wrap.appendChild(pre);
    cards.appendChild(wrap);
  });

  setStatus("Compiled ✅");
}

el("compile").addEventListener("click", compile);

el("copyAll").addEventListener("click", async ()=>{
  const blocks = Array.from(document.querySelectorAll(".scene pre"));
  if (!blocks.length){ setStatus("Nothing to copy"); return; }
  const all = blocks.map(b=>b.textContent).join("\n\n" + "=".repeat(60) + "\n\n");
  try{ await navigator.clipboard.writeText(all); setStatus("Copied ALL ✅"); }
  catch{ setStatus("Copy failed"); }
});

// Prefill from generator
(function(){
  try{
    const h = location.hash||"";
    const m = h.match(/#story=(.*)$/);
    if (m && m[1]){
      el("input").value = decodeURIComponent(m[1]);
      setStatus("Prefilled — click Compile");
    }
  }catch{}
})();
</script>
</body>
</html>
