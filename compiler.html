<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prompt Compiler — Continuity Lock</title>
  <style>
    :root { --r:14px; }
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0d12;color:#eef2ff;line-height:1.35}
    header{padding:22px 18px;border-bottom:1px solid rgba(255,255,255,.08);
      background: radial-gradient(1200px 600px at 20% 0%, rgba(99,102,241,0.22), transparent 60%),
                  radial-gradient(800px 400px at 80% 0%, rgba(16,185,129,0.18), transparent 55%);
    }
    header h1{margin:0 0 6px;font-size:22px}
    header p{margin:0;opacity:.85;max-width:980px}
    a{color:#a5b4fc;text-decoration:none}
    a:hover{text-decoration:underline}
    main{max-width:1200px;margin:0 auto;padding:18px;display:grid;gap:16px}
    .grid{display:grid;gap:16px;grid-template-columns:1fr}
    @media(min-width:980px){.grid{grid-template-columns:520px 1fr}}
    .card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.10);border-radius:var(--r);padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .card h2{margin:0 0 10px;font-size:15px;opacity:.95}
    label{font-size:12px;opacity:.85;display:block;margin-bottom:6px}
    textarea, input{
      width:100%;padding:10px 11px;border-radius:12px;border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.35);color:#eef2ff;outline:none;box-sizing:border-box
    }
    textarea{min-height:220px;resize:vertical}
    .btnbar{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px}
    button{border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);color:#eef2ff;padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:800}
    button.primary{background:rgba(99,102,241,.22);border-color:rgba(99,102,241,.45)}
    button.good{background:rgba(16,185,129,.18);border-color:rgba(16,185,129,.40)}
    button:hover{filter:brightness(1.08)}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:7px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.05);font-size:12px;opacity:.9}
    .muted{opacity:.78}
    .small{font-size:12px;opacity:.8}
    .hr{height:1px;background:rgba(255,255,255,.10);margin:14px 0}
    .out{white-space:pre-wrap;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.10);border-radius:12px;padding:12px;font-size:13px}
    .stack{display:flex;flex-direction:column;gap:12px}
    .sceneCard{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:14px}
    .sceneTop{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-bottom:10px}
    .sceneTop b{font-size:13px}
    .sceneTop .mini{display:flex;gap:8px;align-items:center}
    .k{color:#a5b4fc}
    .warn{color:#fbbf24}
  </style>
</head>

<body>
<header>
  <h1>Prompt Compiler — Continuity Lock</h1>
  <p>
    Paste a <span class="k">Story Frame</span> (Story Core + Story Tram). This tool injects Master Style + exact DNA into every scene prompt.
    <span class="muted">No dialogue. No text. No logos. Photoreal animals.</span>
    <br><a href="./index.html">← Back to Story Generator</a>
  </p>
</header>

<main class="grid">

  <section class="card">
    <h2>1) Input — Story Frame</h2>
    <label>Paste Story Frame (must contain STORY CORE and STORY TRAM)</label>
    <textarea id="input" placeholder="Example:

STORY CORE
- Hero: Willy (Baby Golden Retriever)
- Helper (animal-only): orange tabby cat wearing a tiny firefighter helmet (no text)
- Primary helper role: Firefighter
- Problem: Plush stuck in a tree
- Object of affection: tiny plush bear with a bowtie
- Location: Neutral backyard garden path — weathered stone path, flowers, soft afternoon sunlight
- Weather/Time: Crisp autumn afternoon, falling leaves

STORY TRAM
Scene 1: Calm opening in the garden. Willy sits near the plush.
Scene 2: The plush slips and gets stuck in a tree branch.
Scene 3: The firefighter cat arrives and looks up at the plush.
"></textarea>

    <div class="btnbar">
      <button class="primary" id="compileBtn">Compile Prompts</button>
      <button id="loadExampleBtn">Load Example</button>
      <button id="copyAllBtn">Copy All</button>
      <span class="pill" id="statusPill">Ready</span>
    </div>

    <div class="hr"></div>

    <div class="small muted">
      <b>How it works:</b> For every beat, the compiler repeats the same Master Style header + exact DNA blocks for any mentioned character.
      It also enforces: gaze targets (never camera), prop continuity, and biological body language cues.
    </div>
  </section>

  <section class="card">
    <h2>2) Output — Compiled Scene Prompts</h2>
    <div class="stack" id="outputStack"></div>
    <div class="small muted" style="margin-top:10px;">
      Tip: Each card is a single “final prompt” for a video generator. Copy per scene or copy all.
    </div>
  </section>

</main>

<script>
/* =========================
   INJECTION CONSTANTS
========================= */
const MASTER_STYLE_HEADER =
`10-second cinematic scene. Soft, natural realism with gentle warmth. No dialogue, no text, no subtitles, no logos. Simple, readable action with lively, purposeful movement. Camera: Static or very slow tracking shot. Photorealistic animal anatomy. Natural fur texture and sunlight. NO 3D animation style. NO "Disney" eyes. Physical interactions grounded in physics (objects have weight). NO human limbs.`;

/* DNA Library — verbatim anchors (copy-paste exact text each time) */
const DNA = {
  WILLY: `WILLY: (Baby Golden Retriever puppy, light-golden velvet-soft fluffy fur, short legs, small floppy ears. Simple RED COLLAR. SIGNATURE: A tiny pink "blep" tip of tongue always peeking out of his mouth).`,
  PANBY: `PANBY: (Baby Giant Panda, chubby and round, jet-black fur on limbs/eyes, snow-white fur on head/belly. Small bright YELLOW fabric bowtie).`,
  QUOK: `QUOK: (Baby Quokka, short brown-grey fur, small rounded ears, permanent "smiling" expression).`
};

const CHARACTER_KEYWORDS = [
  { key: "Willy", code: "WILLY" },
  { key: "PANBY", code: "PANBY" },
  { key: "Panby", code: "PANBY" },
  { key: "QUOK", code: "QUOK" },
  { key: "Quok", code: "QUOK" },
];

/* =========================
   PARSING HELPERS
========================= */
const el = (id) => document.getElementById(id);
function setStatus(t){ el("statusPill").textContent = t; }

function normalizeLines(text){
  return (text||"")
    .replace(/\r\n/g,"\n")
    .replace(/\r/g,"\n")
    .split("\n");
}

function findSection(lines, title){
  // returns [startIndex, endIndexExclusive] or null
  const idx = lines.findIndex(l => l.trim().toUpperCase() === title);
  if (idx === -1) return null;
  let end = lines.length;
  for (let i=idx+1;i<lines.length;i++){
    const t = lines[i].trim().toUpperCase();
    if (t === "STORY CORE" || t === "STORY TRAM") { if (i !== idx) end = i; break; }
  }
  return [idx+1, end];
}

function parseCore(lines){
  const sec = findSection(lines, "STORY CORE");
  if (!sec) return null;
  const [a,b] = sec;
  const coreLines = lines.slice(a,b).map(x=>x.trim()).filter(Boolean);

  // very light key parsing: "- Key: value"
  const core = {};
  coreLines.forEach(line=>{
    const m = line.match(/^-?\s*([^:]+)\s*:\s*(.+)\s*$/);
    if (m){
      const k = m[1].trim().toLowerCase();
      const v = m[2].trim();
      core[k] = v;
    }
  });
  return core;
}

function parseTram(lines){
  const sec = findSection(lines, "STORY TRAM");
  if (!sec) return null;
  const [a,b] = sec;
  const tramLines = lines.slice(a,b).map(x=>x.trim()).filter(Boolean);

  // Accept formats:
  // "Scene 1: ..." OR "1) ..." OR "- 1) ..." OR "- Scene 1: ..."
  const beats = [];
  tramLines.forEach(line=>{
    let m = line.match(/^(-\s*)?(scene\s*)?(\d+)\s*[:\)\-]\s*(.+)$/i);
    if (!m) m = line.match(/^(-\s*)?(\d+)\)\s*(.+)$/i);
    if (m){
      const n = parseInt(m[3] || m[2], 10);
      const text = (m[4] || m[3]).trim();
      beats.push({ n, text });
    } else {
      // If it's just text without numbering, still add sequentially
      beats.push({ n: beats.length+1, text: line });
    }
  });

  // Sort by number if present
  beats.sort((x,y)=>x.n-y.n);
  return beats;
}

function detectCharacters(text){
  const found = new Set();
  CHARACTER_KEYWORDS.forEach(k=>{
    if (text.toLowerCase().includes(k.key.toLowerCase())) found.add(k.code);
  });
  return Array.from(found);
}

/* =========================
   PROMPT COMPILER (DETERMINISTIC)
========================= */
function compileScenePrompt(sceneNum, beatText, core){
  const charsMentioned = detectCharacters(beatText);

  // If tram doesn't explicitly name the hero but core has one, we can include it
  const coreHero = core["hero"] || "";
  if (coreHero.toLowerCase().includes("willy")) charsMentioned.includes("WILLY") || charsMentioned.push("WILLY");
  if (coreHero.toLowerCase().includes("panby")) charsMentioned.includes("PANBY") || charsMentioned.push("PANBY");
  if (coreHero.toLowerCase().includes("quok"))  charsMentioned.includes("QUOK")  || charsMentioned.push("QUOK");

  // Build Character States block (verbatim anchors)
  const charStates = charsMentioned.length
    ? charsMentioned.map(code => DNA[code]).join("\n")
    : "(No core character names detected. Add 'Willy'/'Panby'/'Quok' to the beat for DNA injection.)";

  // Props / physics from core
  const object = core["object of affection"] || core["object"] || "";
  const problem = core["problem"] || "";
  const helper = core["helper (animal-only)"] || core["helper"] || "";
  const role = core["primary helper role"] || core["role"] || "";
  const location = core["location"] || "";
  const weather = core["weather/time"] || core["weather"] || "";

  const propsPhysics =
`PROPS & PHYSICS:
- All props maintain exact color, scale, and markings from previous scenes. Realistic weight and gravity.
- If any vehicle/tool appears, it is toy-scale unless explicitly stated otherwise.
- Object of affection: ${object || "(none specified)"}.
- Problem reference (if relevant): ${problem || "(none specified)"}.
- Location continuity: ${location || "(not specified)"}.
- Weather continuity: ${weather || "(not specified)"}.
- No logos, no readable text on props.`;

  const gaze =
`GAZE TARGET (Interaction Rule):
- Characters look at each other or at the object/problem. NEVER look at the camera.`;

  const body =
`BIOLOGICAL BODY LANGUAGE:
- Emotions shown via physical cues only (ears, tail, whiskers, posture, paw movement, breathing).
- No abstract words like “thinks/realizes/decides” in the description.`;

  // Deterministic “Description” scaffolding:
  // Keep the beat, but force literal visuals and 1-action emphasis.
  const description =
`DESCRIPTION (Blind-Viewer Protocol):
In ${location || "a consistent outdoor setting"}, under ${weather || "soft natural light"}, the camera is static or slowly tracking. ${beatText.trim()}
Only one clear movement happens in this scene. Everything else stays still or slow for clarity.`;

  // Include helper details if present
  const helperLine = helper || role
    ? `\nHELPER CONTINUITY:\n- Helper present (animal-only): ${helper || "(not specified)"}.\n- Helper role: ${role || "(not specified)"}.\n`
    : "";

  // Final prompt with injections
  return [
    `SCENE ${sceneNum}`,
    ``,
    `MASTER STYLE HEADER:`,
    MASTER_STYLE_HEADER,
    ``,
    description,
    ``,
    `CHARACTER STATES (Verbatim Anchor):`,
    charStates,
    helperLine ? helperLine.trimEnd() : "",
    gaze,
    ``,
    propsPhysics,
    ``,
    body,
    ``,
    `REMEMBER (Continuity Lock):`,
    `- Repeat the exact same character accessories every scene (Willy RED collar + tiny pink blep; Panby YELLOW bowtie; Quok permanent smile).`,
    `- Maintain consistent sizes: babies remain baby-sized relative to toy-scale props.`,
    `- Cause → effect must be visually readable.`,
  ].filter(Boolean).join("\n");
}

/* =========================
   RENDERING
========================= */
function clearOutput(){
  el("outputStack").innerHTML = "";
}

function addSceneCard(sceneNum, promptText){
  const wrap = document.createElement("div");
  wrap.className = "sceneCard";

  const top = document.createElement("div");
  top.className = "sceneTop";

  const title = document.createElement("b");
  title.textContent = `Scene ${sceneNum}`;

  const mini = document.createElement("div");
  mini.className = "mini";

  const copyBtn = document.createElement("button");
  copyBtn.textContent = "Copy";
  copyBtn.className = "good";
  copyBtn.style.padding = "8px 10px";
  copyBtn.addEventListener("click", async ()=>{
    try{
      await navigator.clipboard.writeText(promptText);
      setStatus(`Copied Scene ${sceneNum}`);
    }catch{
      setStatus("Copy failed");
    }
  });

  mini.appendChild(copyBtn);
  top.appendChild(title);
  top.appendChild(mini);

  const pre = document.createElement("div");
  pre.className = "out";
  pre.textContent = promptText;

  wrap.appendChild(top);
  wrap.appendChild(pre);
  el("outputStack").appendChild(wrap);
}

async function copyAll(){
  const cards = Array.from(document.querySelectorAll(".sceneCard .out"));
  if (!cards.length) { setStatus("Nothing to copy"); return; }
  const all = cards.map((c,i)=>c.textContent).join("\n\n" + "=".repeat(60) + "\n\n");
  try{
    await navigator.clipboard.writeText(all);
    setStatus("Copied ALL scenes");
  }catch{
    setStatus("Copy failed");
  }
}

/* =========================
   MAIN COMPILE
========================= */
function compile(){
  clearOutput();
  const text = el("input").value || "";
  const lines = normalizeLines(text);

  const core = parseCore(lines);
  const tram = parseTram(lines);

  if (!core){
    setStatus("Missing STORY CORE");
    el("outputStack").innerHTML = `<div class="out"><span class="warn">ERROR:</span> Could not find a line that equals "STORY CORE". Add it exactly.</div>`;
    return;
  }
  if (!tram || !tram.length){
    setStatus("Missing STORY TRAM");
    el("outputStack").innerHTML = `<div class="out"><span class="warn">ERROR:</span> Could not parse STORY TRAM beats. Add lines like "Scene 1: ..."</div>`;
    return;
  }

  // Deterministic compilation order: use tram order
  tram.forEach((b, idx)=>{
    const sceneNum = b.n || (idx+1);
    const prompt = compileScenePrompt(sceneNum, b.text, core);
    addSceneCard(sceneNum, prompt);
  });

  setStatus(`Compiled ${tram.length} scenes`);
}

/* =========================
   EXAMPLE
========================= */
function loadExample(){
  el("input").value =
`STORY CORE
- Hero: Willy (Baby Golden Retriever)
- Helper (animal-only): orange tabby cat wearing a tiny firefighter helmet (no text)
- Primary helper role: Firefighter
- Problem: Plush stuck in a tree
- Object of affection: tiny plush bear with a bowtie
- Location: Neutral backyard garden path — weathered stone path, flowers, soft afternoon sunlight
- Weather/Time: Crisp autumn afternoon, falling leaves

STORY TRAM
Scene 1: Calm opening. Willy sits near the tiny plush bear on the stone path.
Scene 2: The plush slips from Willy’s paws and lands on a low branch in the tree.
Scene 3: The firefighter cat arrives, stops, and looks up at the plush.
Scene 4: The cat places a toy ladder against the tree trunk.
Scene 5: The cat climbs one step, the ladder wobbles, and the cat pauses.`;
  setStatus("Example loaded");
}

/* =========================
   BIND
========================= */
el("compileBtn").addEventListener("click", compile);
el("loadExampleBtn").addEventListener("click", loadExample);
el("copyAllBtn").addEventListener("click", copyAll);

// Auto-load example first time for convenience
loadExample();
</script>
</body>
</html>
